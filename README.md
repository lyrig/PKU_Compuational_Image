## CGI 第一次作业（渲染部分）：

### Problem 1 (20%)

在 ```problem1.h``` 中实现将三维空间内的任意点 p 转换到相机的局部投影坐标系下的点 q 的相互转换：

处理方法：
*  Step 1: 把三维坐标系内的任意点 p 转换到以 directFront 为正上，directUp 为正前，directX 为正右，eyePos 为相机原点的相机坐标系下的点 m。
*  Step 2: 把相机坐标系下的点 m 进行投影变换, 转换到相机的投影坐标系下的点 q。

Step 1,2 两步均可以写成矩阵乘法的形式，你需要补充矩阵乘法中的矩阵生成部分。

可能使用的变量定义如下：

```cpp
class Camera
{    
    // rendering.h, Line 474
    Vector4 eyePos;      // 相机位置
    Vector4 directFront; // 相机视角下，向前的方向
    Vector4 directUp;    // 相机视角下，向上的方向
    Vector4 directX;     // 相机视角下，向右的方向

    double zNear = 0.1, zFar = 500; // 相机近点，远点
    double FofV = 90;               // 相机视角大小
    double ratio = 4.0 / 3.0;       // 相机画布长宽比

    ......
}
```

### Problem 2 (20%)

在 ```problem2.h``` 中填补实现 Blinn-Phong 光反射模型。

输入：
* col: 当前点本身贴图的颜色，三个通道均为 [0 ~ 1] 的浮点数值。
* loc: 当前点的位置，在原始的三维坐标系下存储（不是相机局部坐标系，也不是投影后的坐标系）
* Norm: 当前点平面的法向量，在原始的三维坐标系下存储（不是相机局部坐标系，也不是投影后的坐标系），不保证是个单位向量。

输出:
* 当前点在 Blinn-Phong 下光照的颜色。

处理方法：
* 点光源的高光
* 点光源的漫反射
* 平行光源的漫反射
* 强度为 light.ka 的环境光。

可能使用的变量定义如下：

```cpp
class Rendering
{
    // rendering.h, Line 560
    ......
    Vector4 camera.eyePos; // 相机所处的位置
    Vector4 light.pLightdirect[0]; // 点光源的位置，这里假设点光源是白光。
    Vector4 light.dLightpos[0]; // 平行光源的光照方向（是向量，不是标量！）
    double light.ka; // 环境光强度系数
    double light.kd; // 漫反射强度系数
    double light.ks; // 高光强度系数
    double light.ns; // 高光强度计算时候的幂次系数
    Color Color::White(); // 返回白光信息
    ......
}
```

### Problem 3 (20%)

在 ```problem3.h``` 中填补在预处理好的 Mipmap 结构中，使用双线性插值法找到第 level 层的 (x, y) 对应的颜色信息的相关代码。

输入：
* level: 查询的 Mipmap 层数，处理后保证不超过预处理时候计算的总层数，也就是不超过 (int)Mipmap.size() - 1
* x, y: 二维坐标，范围在 [0, 1] 之间，表示查询的坐标。我们假设整个纹理的左下角为 (0, 0)，右上角为 (1, 1)。
输出：
* Color 类型，表示 (x, y) 点在第 level 层的 mipmap 上对应的颜色信息。颜色需要从 [0 ~ 255] 整数值映射到 [0 ~ 1] 的浮点数值。
  
处理方法：
* 1. 计算 (x, y) 对应的在第 level 层的 Mipmap 上的坐标，记为 (doubleX, doubleY)
* 2. 计算 (doubleX, doubleY) 对应的方格的四个格点。
* 3. 对四个格点的颜色进行双线性插值，得到 (doubleX, doubleY) 对应的颜色信息，返回即可。
  
可能使用到的变量集合：

```cpp    
    // rendering.h, Line 133
    int32_t _h,_w; // 原始贴图的高度和宽度
    vector<vector<uint8_t>> _bit; // 原始贴图的颜色信息，存储方式为 第 i 行第 j 列的第 k 个颜色 channel 信息存储在 _bit[i][3j+k] 中
    vector<vector<vector<uint8_t>>> Mipmap; // Mipmap 分层贴图信息，第 0 层表示原始贴图信息。
                                            // 第 i 层的贴图高度，宽度恰好为第 i - 1 层的 1/2
                                            // 每一层贴图存储方式与 _bit 中贴图的存储方式相同
    vector<int32_t> _MipmapH; //Mipmap 分层贴图中每一层的高度
    vector<int32_t> _MipmapW; //Mipmap 分层贴图中每一层的宽度
    
    double alpha = 1.1; //模糊参数
    bool covered; //贴图是否初始化
```

### Problem 4 (40%)

将已经完成的 Problem 1, Problem 2, Problem 3 的代码整体拷贝到新文件夹 ```Problem 4```. 后，由同学在 ```Problem 4``` 下的环境内，自行选择一项或者多项对上述渲染框架的改进内容：

以下是一些示例的修改内容：

* 非真实感渲染：使用 Toon/Cel Shading 实现卡通效果
* 简单光线追踪：在 Problem 3 中实现的 Blinn-Phong 的基础上，添加物体遮挡点光源/平行光源的光线的判定，以此生成地面的阴影效果。测试时候需要提供地面(可以没有花纹) 以及至少一处地面上的阴影效果。
* 视角外物体检查：在 rendering.h 中 drawModel 函数内，处理三角形面片的时候，我们没有处理完全/部分位于相机视平面之外的面片。添加该类型面片的处理规则（有可能需要对面片进行挑选/拆分），且测试时候需要至少有一个物体可以被看见，但是该物体部分位于相机之后。
* 模型加载：文件夹下额外提供了使用 obj + bmp 纹理方式的怪物的角色。将其加载到环境当中。处理时候需要注意模型加载与纹理映射的关系
* 法线贴图：我们只实现了纹理贴图，没有实现法线贴图。通过法线贴图的方式，实现更加逼真的圆形效果。实现的时候注意法线贴图的向量是相对于面片平面的局部坐标系的，而不是相对于模型局部坐标系的。
* 移位贴图（Displacement Map）：类似于法线贴图，但是物体的形状真实发生了改变，同时法线也相应的变化
* 其他你想做的内容....

注意：在problem4中你可以任意改动物体的位置和形状。

### 提交内容：

* 问题一 ```problem1.h```, 
* 问题二 ```problem2.h```, 
* 问题三 ```problem3.h```,
* 问题四 ```problem4.md```, 说明问题四选择完成的内容，你的代码修改思路，代码编译方式以及运行方式，以及一个文件夹 ```problem4```，表示你在问题三的基础上修改的代码框架。你需要尽可能保证助教能够编译 ```problem4``` 的内容。

### 本机调试方法

随作业下发的有 ```problem1.cpp``` 至 ```problem4.cpp```，同学可以通过执行如下命令，在本机测试相关代码：

```bash
g++ problem1.cpp -o p1 -O2 -std=c++11
problem{X}
```
其中 X 为 1 到 4 的整数，表示进行测试的小问。

对于 Problem 1,2,3, 测试会运行渲染框架，生成渲染出来的 ```bmp``` 图片。我们在 ```参考渲染结果``` 文件夹下给出了参考结果，同学可以自行比对。

对于 Problem 4, 选手可以自行修改包括主函数，渲染框架在内的代码，来完成不同的功能测试任务。如果有多个测试任务，可以使用多个不同的主函数进行测试，并在提交的时候分别注明多个测试内容对应的编译/运行方式。

### 评分细则

对于 Problem 1,2,3, 使用提交的 ```problem{X}.h``` 进行渲染测试。根据渲染图片的质量酌情给分。

对于 Problem 4, 使用同学提交的代码以及编译方式进行测试，并针对任务的完成程度以及质量给分。作为参考，实现示例中的任何一项修改内容，且没有代码错误的条件下，同学都可以在本问题获得至少 30 分的分数。